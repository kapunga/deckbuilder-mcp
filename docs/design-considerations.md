# Deck Builder MCP Design Considerations

## Overview

Deck Builder MCP is a prototype MCP project aimed at making it very easy to build a Magic The Gathering deck with the assistance of AI tools such as Claude Desktop. The motivation for this project comes from having a lot of cards, but not a lot of time to engage in the project of building effective decks for fun and enjoyment with friends. Managing a large collection seems like a full time job and the goal of this project is to allow a less engaged player to quickly put together some decks using the new AI assistants that have become available.

## Design Considerations

There are several design considerations that are front of mind as I start to work on this project that are non-negotiable as they are what would make the project successful for me.

### Minimizing AI Assistant Load

Minimizing the amount of work AI assistants have to do to interact with the tools is of the utmost importance. Given the volume of cards that can be read, it is really easy to run out of context room in a given conversation with a tool. I ran into this problem frequently when I began using Claude to assist me in deck building.

Here is what appeared to be happening when I tried to build a deck the first few times with the Scryfall MCP server. Scryfall is the definitive source for card information, and they have API access which is great. This API access does not require any authentication, which is equally great and makes it very accessible, especially for people who are trying to throw things together quickly who might not have a lot of experience in software development, particularly managing tokens and the like. The problem with the Scryfall MCP server however is that it appears to have been put together by someone quickly with a minimum of experience engineering for AI applications. It is very small and essentially just provides a pass through interface to the underlying API.

The main problem with this is that there was little attention paid to filtering down the information being passed by the server, resulting in an enormous amount of token usage. This token usage came from two sources, the first of which is the JSON formatting of the responses. JSON is great for interacting with things programmatically in a human readable fashion. When interacting with foundation models however, it introduces a lot of extra tokens just from the syntax. On top of this, since Scryfall is so comprehensive, including the entire unfiltered JSON response object introduces a lot of irrelevant information, and thus tokens, into the conversational context. All of these extra tokens, puts extra load on the foundation model you are interacting with which both slows down the inference speed and reduces the quality of the resulting inferences.

The solution to this problem is to make sure that any MCP tool implements smarter formatting and information filtering in any results it returns from Scryfall. Some ways in which this could be done include the following:

* **Dense Markdown Card Format** - Some of the newer foundation models are very smart when it comes to Magic the Gathering and know what to expect on a card. Because of this, a human readable text description of a card relying primarily on the order in which informations appears, such as card name, casting cost, set code & card number, etc. is perfectly legible to a foundation model, and as such, no extra formatting tokens need to be spent separating data as one might expect to do when generating text to be consumed programmatically.

* **Contextual Text Filters** - There are a variety of reasons you might be looking up a card and not all of them are relevant in every context. You may be working on building a deck, in which case the card text, type, power & toughness, etc. are of the utmost importance, whereas when you are trying to sift through your collection for cards that you might be willing to sell or trade, you might just care about rarity and current cost, in which case you can include a lot less information.

* **Higher Level Tool Abstractions** - Foundation models are extremely capable of breaking down complex tasks into simpler tasks. You can absolutely make the simplest tools possible and allow the foundation model to perform arbitrarily complex tasks by breaking them down to the point where it can make discreet tool calls. However this strategy is a bit wasteful and introduces the opportunity for the foundation model to make errors in the decomposition.
Going back to the deck building example. My rough and ready set of tools for deck building was the overly verbose Scryfall api and the filesystem tool. This introduced several problems.

  * **Overly complex file operations** - When modifying the deck, Claude had to make file modifications to the deck list that required interacting with an entire file, reading it to re-understand the structure, and making sure to write in the appropriate place. Claude was responsible for maintaining the structure of deck list and thus a lot of excess tokens were spent just from reading and writing the entire file, plus figuring out what operations need to be done. This problem is compounded when I want to have different views of a deck list, for example a simple list sorted in an optimized order for physical retrieval of cards. Claude had to make two lists, keep them in sync, and not make any mistakes in consistency between views. Asking Claude to double check multiple views on a card list for errors eats up additional context.

  * **Claude makes arithmetic mistakes** - One thing general foundation models are often bad at is simple arithmetic on complex word problems. In the building of deck lists this came up in at least two ways. The first is that Claude would often lose track of how many cards were in a deck we were composing. The second would be errors in calculating the mana curve of the deck, which is a breakdown of card counts by the converted casting cost of the cards.

  The above problems are problems that are very easy to solve programmatically. There are enormous operations for Claude that can be sidestepped simply by having an appropriate tool implementation. For example current deck count and mana curve calculations as well as alternate views could be done programmatically, eliminating the need for Claude to do excess work as well as providing more accuracy. Operations such as adding a card to a deck or swapping out one card for another could be made incredibly simple for Claude, rather than the complex operation of reading and multiple files and making synchronous edits.
